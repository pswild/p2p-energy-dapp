'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CHASQUI_URL = exports.isMessageServerCallback = exports.genCallback = exports.clearResponse = exports.poll = exports.URIHandlerSend = undefined;

var _util = require('./../message/util.js');

var _crypto = require('./../crypto.js');

var _poll = require('./poll.js');

var _poll2 = _interopRequireDefault(_poll);

var _didJwt = require('did-jwt');

var _nets = require('nets');

var _nets2 = _interopRequireDefault(_nets);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var CHASQUI_URL = 'https://api.uport.space/chasqui/';
var POLLING_INTERVAL = 2000;

// TODO can the name of URIHandler be changed
// TODO should it just allow cancel func to be passed in??
// TODO Should it return uri append to promise? instead of a promise??
/**
 *  A general Chasqui Transport. Allows you to configure the transport with any uriHandler for the request,
 *  while the response will always be returned through Chasqui. Chasqui is a simple messaging server that
 *  allows responses to be relayed from a uport client to the original callee.
 *
 *  @param    {String}       uriHandler               a function called with the requestURI once it is formatted for this transport
 *  @param    {Object}       [config={}]              an optional config object
 *  @param    {String}       [config.chasquiUrl]      url of messaging server, defaults to Chasqui instance run by uPort
 *  @param    {String}       [config.pollingInterval] milisecond interval at which the messaging server will be polled for a response
 *  @return   {Function}                              a configured QRTransport Function
 *  @param    {String}       message                  a uPort client request message
 *  @return   {Promise<Object, Error>}                a function to close the QR modal
 */
var URIHandlerSend = function URIHandlerSend(uriHandler) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$messageServerUrl = _ref.messageServerUrl,
      messageServerUrl = _ref$messageServerUrl === undefined ? CHASQUI_URL : _ref$messageServerUrl,
      _ref$pollingInterval = _ref.pollingInterval,
      pollingInterval = _ref$pollingInterval === undefined ? POLLING_INTERVAL : _ref$pollingInterval;

  if (!uriHandler) throw new Error('uriHandler function required');
  return function (message) {
    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var uri = (0, _util.messageToURI)(message);
    var callback = getCallback(uri);
    if (!isMessageServerCallback(uri, messageServerUrl)) throw new Error('Not a request that can be handled by this configured messaging server transport');
    var isCancelled = false;
    var cancel = function cancel() {
      isCancelled = true;
    };
    uri = (0, _util.paramsToQueryString)(uri, { callback_type: 'post' });
    uriHandler(uri, Object.assign(params, { cancel: cancel }));
    var returnVal = poll(callback, pollingInterval, function () {
      return isCancelled;
    });
    returnVal.cancel = cancel;
    return returnVal;
  };
};

/**
 *  A polling function specifically for polling Chasqui.
 *
 *  @param    {String}                  url                a Chasqui url polled
 *  @param    {Integer}                 [pollingInterval]  ms interval at which the given url is polled
 *  @param    {Function}                [cancelled]        function which returns boolean, if returns true, polling stops
 *  @return   {Promise<Object, Error>}                     a promise which resolves with obj/message or rejects with an error
 */
var poll = function poll(url, pollingInterval, cancelled) {
  var messageParse = function messageParse(res) {
    // Support new and old chasqui format
    var message = res.message && ('content' in res.message ? JSON.parse(res.message.content) : res.message);
    // FIXME: this is not a great method for handling our expected keys in the response.
    //        Very tightly coupled to the message format, and these keys seem to come out
    //        of nowhere.
    if (message) {
      return message['access_token'] || message['tx'] || message['typedDataSig'] || message['personalSig'];
    }
  };
  var errorParse = function errorParse(res) {
    if (res.message) return res.message.error;
  };
  return (0, _poll2.default)(url, messageParse, errorParse, cancelled, pollingInterval).then(function (res) {
    clearResponse(url);
    return res;
  });
};

// TODO maybe remove and just have reasonable removal times
var clearResponse = function clearResponse(url) {
  (0, _nets2.default)({
    uri: url,
    method: 'DELETE',
    withCredentials: false,
    rejectUnauthorized: false
  }, function (err) {
    if (err) {
      throw err;
    } /* Errors without this cb */
  });
};

var formatMessageServerUrl = function formatMessageServerUrl(url) {
  if (url.endsWith('/topic/')) return url;
  if (url.endsWith('/topic')) return url + '/';
  if (url.endsWith('/')) return url + 'topic/';
  return url + '/topic/';
};
var genCallback = function genCallback() {
  var messageServerUrl = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : CHASQUI_URL;
  return '' + formatMessageServerUrl(messageServerUrl) + (0, _crypto.randomString)(16);
};
var isMessageServerCallback = function isMessageServerCallback(uri) {
  var messageServerUrl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CHASQUI_URL;
  return new RegExp(formatMessageServerUrl(messageServerUrl)).test(getCallback(uri));
};
var getCallback = function getCallback(uri) {
  var tokenCB = (0, _didJwt.decodeJWT)((0, _util.getURLJWT)(uri)).payload.callback;
  if (tokenCB) return tokenCB;
  // support attest req, which does not included cb in token, attest req may better align with other requests in the future
  return (0, _util.getUrlQueryParams)(uri).callback_url;
};

exports.URIHandlerSend = URIHandlerSend;
exports.poll = poll;
exports.clearResponse = clearResponse;
exports.genCallback = genCallback;
exports.isMessageServerCallback = isMessageServerCallback;
exports.CHASQUI_URL = CHASQUI_URL;